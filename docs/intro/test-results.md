## 评测

在 OI 中，选手写出的源程序一般不是直接交给教练审阅的。实际上在早期的 IOI 比赛中是这样，但是随着 OI 的发展，这种做法很难处理一题多解（例如一些题可以有奇怪的贪心做法），并且很难评估程序所用时间，又耗费人力物力，所以判断程序是否合格的方法就变为黑盒机制了。

黑盒机制的大致思路是，如果一份源代码所编译出来的可执行文件在**所有数据**上都**不会崩溃**，并且能够在给定的**时间**和**内存限制**内给出**正确的答案**，那么这份源代码就是正确的。实际上不可能测完所有数据，所以一般会选取几组具有代表性的数据来测试。

这种一句黑盒机制的判断方法就叫评测。

## 测试点要素和数据范围

在上文提到过，因为我们不可能测完所有数据，所以只能选取几组具有代表性的数据进行测试，每一组被选取的数据都叫做一个“测试点”。

在标准的 OI 题目内，每一个测试点包含以下要素：

+ 输入数据和输出数据。用于程序的输入，以及对比程序输出答案是否正确。
+ 时间限制。限制程序的运行时间。
+ 空间限制。限制程序运行时所占用的动态空间。

??? note: "什么是运行时占用的动态空间"
    指程序在运行的时候所**实际使用**的最大内存空间的大小。例如，如果你的程序先申请了 3MB 的大小，再释放掉，随后又申请 4MB，动态内存空间占用就只是 4MB 而非 7MB。
    
    递归栈也会被计入动态空间以内，所以递归层数过深也会造成空间超限。

而在题面中，不可能给出每一组具体的输入数据（实际有例外，见“非标准 OI 题目”一节），因此就采取描述几个主要变量的范围的方法来限定程序的效率。

例如，如果题目是简单的排序，那么数组元素的个数 $n$ 就很有可能在数据范围中描述它的范围。如果数据范围中限定 $n\leq 1000$，那么就可以使用插入排序和冒泡排序等时间复杂度为 $\Theta(n^2)$ 的算法。如果限定 $n\leq 10^6$，那么只能使用快速排序等时间复杂度在 $\Theta(n\log n)$ 的算法了。

一些题目会有“部分分”的设置，即给每个单独的测试点一些分数，通过这些测试点就能拿到一定分数。每个测试点的数据范围可以不同，这样可以保证较劣的解法也可以拿到一定分数，不至于使得分太极端（满分或零分）。另外还有 subtask 的设定，即通过一个 subtask 中的所有数据点才能拿到对应分数。有一些赛制是没有部分分一设定的，具体见 [这里](./oi/#_4)。

一个标准的题目应该有数据范围、时间限制、空间限制、数据的输入格式和答案的输出格式的描述。例如，一道标准的排序题的数据范围可能是 $n\leq 1000$，时间限制 1.00s，空间限制 128MB。

需要注意的是，一般比对标准答案和你的输入的方式都是过滤文末换行和行末空格之后进行全文比对。一些题目会有特殊的比对方法，见“非标准 OI 题目”一节。一些老的评测平台会不过滤文末换行和行末空格，这时候如果有多余的换行或空格的话会被评为 PE。

## 评测结果

根据你的程序的表现，会有以下几个结果：

+ Accepted(AC)：你的程序满足了所有要求，被接受了。
+ Wrong Answer(WA)：你的程序输出了结果，但是给出了错误的答案。
+ Time Limit Exceeded(TLE)：你的程序运行时间超出了限定的时间。
+ Memory Limit Exceeded(MLE)：你的程序所占用的动态空间超出了限定的空间。
+ Runtime Error(RE)：你的程序在运行的时候崩溃了，或者调用了不被允许的系统函数。
+ Complie Error(CE)：你的程序没有通过编译，或者没有生成合法的可执行文件。
+ Presentation Error(PE)：你的程序输出大致正确，但是格式错误。已经很少出现了。
+ Output Limit Exceeded(OLE)：你的程序输出太多了。

## 非标准 OI 题目

除以下列出的分类以外，还有通信题等。不展开。

### SPJ

SPJ，全称 Special Judge，指题目在比对的时候并不是机械的进行全文比对，而是通过某种规则判断你的输出正不正确。最常见的情况是一题多解、输出方案且方案不唯一、输出小数的时候为了避免精度问题。

### 提交答案题

简称“提答题”，题目在开头就给出每一组具体的输入数据，要求上交每一组对应的答案。

### 交互题

指你的程序不是一次性输入和一次性输出，而是通过一个交互程序来交互式地获取输入。最常见的例子是猜数字，每次输出一个数字，然后输入猜的是偏大还是偏小。

### 通信题

你的程序的任务是在给定的限制下完成通信，即你需要准备两份程序，在受限的情况下相互通信，最后得到结果。
