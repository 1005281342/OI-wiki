## 评测

在 OI 中，选手写出的源程序一般不是直接交给教练审阅的。实际上在早期的 IOI 比赛中是这样，但是随着 OI 的发展，这种做法很难处理一题多解（例如一些题可以有奇怪的贪心做法），并且很难评估程序所用时间，又耗费人力物力，所以判断程序是否合格的方法就变为黑盒机制了。

黑盒机制的大致思路是，如果一份源代码所编译出来的可执行文件在**所有数据**上都**不会崩溃**，并且能够在给定的**时间**和**内存限制**内给出**正确的答案**，那么这份源代码就是正确的。实际上不可能测完所有数据，所以一般会选取几组具有代表性的数据来测试。

这种一句黑盒机制的判断方法就叫评测。

## 测试点要素和数据范围

在上文提到过，因为我们不可能测完所有数据，所以只能选取几组具有代表性的数据进行测试，每一组被选取的数据都叫做一个“测试点”。

在标准的 OI 题目内，每一个测试点包含以下要素：

+ 输入数据和输出数据。用于程序的输入，以及对比程序输出答案是否正确。
+ 时间限制。限制程序的运行时间。
+ 空间限制。限制程序运行时所占用的动态空间。

??? note: "什么是运行时占用的动态空间"
    指程序在运行的时候所**实际使用**的最大内存空间的大小。例如，如果你的程序先申请了 3MB 的大小，再释放掉，随后又申请 4MB，动态内存空间占用就只是 4MB 而非 7MB。
    
    递归栈也会被计入动态空间以内，所以递归层数过深也会造成空间超限。

而在题面中，不可能给出每一组具体的输入数据（实际有例外，见“非标准 OI 题目”一节），因此就采取描述几个主要变量的范围的方法来限定程序的效率。

例如，如果题目是简单的排序，那么数组元素的个数 $n$ 就很有可能在数据范围中描述它的范围。如果数据范围中限定 $n\leq 1000$，那么就可以使用插入排序和冒泡排序等时间复杂度为 $\Theta(n^2)$ 的算法。如果限定 $n\leq 10^6$，那么只能使用快速排序等时间复杂度在 $\Theta(n\log n)$ 的算法了。

一些题目会有“部分分”的设置，即给每个单独的测试点一些分数，通过这些测试点就能拿到一定分数。每个测试点的数据范围可以不同，这样可以保证较劣的解法也可以拿到一定分数，不至于使得分太极端（满分或零分）。另外还有 subtask 的设定，即通过一个 subtask 中的所有数据点才能拿到对应分数。有一些赛制是没有部分分一设定的，具体见 [这里](./oi/#_4)。

一个标准的题目应该有数据范围、时间限制、空间限制、数据的输入格式和答案的输出格式的描述。例如，一道标准的排序题的数据范围可能是 $n\leq 1000$，时间限制 1.00s，空间限制 128MB。

需要注意的是，一般比对标准答案和你的输入的方式都是过滤文末换行和行末空格之后进行全文比对。一些题目会有特殊的比对方法，见“非标准 OI 题目”一节。一些老的评测平台会不过滤文末换行和行末空格，这时候如果有多余的换行或空格的话会被评为 PE。

## 评测结果

根据你的程序的表现，会有以下几个结果：

+ Accepted(AC)：你的程序满足了所有要求，被接受了。
+ Wrong Answer(WA)：你的程序输出了结果，但是给出了错误的答案。
+ Time Limit Exceeded(TLE)：你的程序运行时间超出了限定的时间。
+ Memory Limit Exceeded(MLE)：你的程序所占用的动态空间超出了限定的空间。
+ Runtime Error(RE)：你的程序在运行的时候崩溃了，或者调用了不被允许的系统函数。
+ Complie Error(CE)：你的程序没有通过编译，或者没有生成合法的可执行文件。
+ Presentation Error(PE)：你的程序输出大致正确，但是格式错误。已经很少出现了。
+ Output Limit Exceeded(OLE)：你的程序输出太多了。

## 非标准 OI 题目

除以下列出的分类以外，还有通信题等。不展开。

### SPJ

SPJ，全称 Special Judge，指题目在比对的时候并不是机械的进行全文比对，而是通过某种规则判断你的输出正不正确。最常见的情况是一题多解、输出方案且方案不唯一、输出小数的时候为了避免精度问题。

### 提交答案题

简称“提答题”，题目在开头就给出每一组具体的输入数据，要求上交每一组对应的答案。

### 交互题

指你的程序不是一次性输入和一次性输出，而是通过一个交互程序来交互式地获取输入。最常见的例子是猜数字，每次输出一个数字，然后输入猜的是偏大还是偏小。

### 通信题

你的程序的任务是在给定的限制下完成通信，即你需要准备两份程序，在受限的情况下相互通信，最后得到结果。

## OI 中不同的赛制

这里的介绍主要偏向于题目的构成和计分方法方面，另一方面（如总时间、题目数量、允不允许组队）等可以查看。

### OI 赛制

NOIP、NOI、省选等采用的是 OI 赛制。

OI 赛制在一开始只下发题目和几组样例，选手写好程序之后等待比赛结束，然后统一评测。OI 赛制下只有一次评测机会。

OI 赛制有部分分的设定。部分分就是将各个测试点赋予不同的分数，如果通过这个测试点就能得到一定分数。有时还会有 subtask 的设定，同一个 subtask 中有一组类似的测试点，要通过该 subtask 下的每一个测试点才可拿到该 subtask 的分数。

### IOI 赛制

APIO、IOI 等采用的是 IOI 赛制。

IOI 赛制和 OI 赛制的区别在于 IOI 赛制可以允许无限次提交程序，每次提交都能得到评测结果，方便及时修改。与 OI 赛制相同，IOI 赛制有部分分的设定。

### ACM 赛制

ACM/ICPC 系列比赛一般采用 ACM 赛制。

ACM 赛制使用过题数（即 AC 几道题）来排名，过题数相同按照总用时（即 AC 所用的时间）排序，用时越短排名越前。也可以无限次提交，如果评测错误的话就会有罚时，即在原来用时的基础上加一定时间（一般是 20 分钟）。

ACM 赛制没有部分分。

### 乐多赛制

Luogu 中的比赛有一些使用乐多赛制。

乐多赛制和 IOI 赛制的区别在于乐多赛制多次提交会有罚分，将这一题的最终得分降低一定百分比，最低到 97%。所以乐多赛制要 AK（得到满分）只能每道题都一遍过。

乐多赛制也有部分分的设定。

### CF 赛制

Codeforces 中的比赛一般都用 CF 赛制。

CF 赛制中对于每道题都有一个 Pretest，如果通过了 Pretest 可以将这题锁定（即不能再提交），然后就可以 Hack 别人这一题的代码（即对别人的代码给出让他错误的数据）。结束后会将所有程序在所有 Hack 成功的数据上跑一遍，全部通过才能 AC，没能通过被称作 Failed System Test（FST）。
